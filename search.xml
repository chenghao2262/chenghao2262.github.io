<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[netty 学习笔记（一）]]></title>
    <url>%2F2018%2F11%2F05%2Fnetty-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NETTY-学习笔记（一） netty is an advanced framework for creating high-performance networking applications— netty in action netty初见挑战：如何让自己编写的应用程序支持150000以上的并发？ 传统的java代码如何实现网络访问以下是一段传统java网络处理代码 1234567891011121314ServerSocket serverSocket = new ServerSocket(portNumber);Socket clientSocket = serverSocket.accept();BufferedReader in = new BufferedReader( new InputStreamReader(clientSocket.getInputStream()));PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);String request, response;while ((request = in.readLine()) != null) &#123; if ("Done".equals(request) ( break; &#125; response = processRequest(request); out.println(response);&#125; 简而言之，这段代码做了一下几件事。 serverSocket 绑定到一个port端口 accept()等待连接建立 不断地readLine()读取数据并返回response 从这段代码可以看出，在同一时刻只能处理一个链接，如果要处理多并发，则需要多个线程，每个线程处理一个socket client。如果我们采用传统的网络模型来支持高并发，会造成一下问题 首先大部分时间，大部分线程都在等待，线程利用率非常底下。 其次每个线程都需要栈内存开销，从64KB-1MB不等，当并发数量过多时，会大大消耗内存资源，造成OutOfMemoryException。 线程切换开销等操作同样会消耗过多的cpu资源。 Java NIOJava 1.4开始引入一种新的IO API，称为NIO，NIO有两种解释，New Input/Output 和 Non-blocking Input/Output ,但是无所谓了，哪种解释都可以。这里采用New Input/Output，对应的传统IO成为OIO。NIO和OIO最大差别在于socker的read/write操作在没有数据的时候会直接返回。这样将不会造成阻塞。NIO将通过一个selector来选择IOready的socket。 好处非常明显。 不会阻塞，由selector检查所有socket状态，而非等待一个socket IO ready。 处理线程和socket解耦，线程可以高效利用起来，比如当IO等待时，线程可以归还到线程池处理别的任务。 我们需要netty从JDK1.4起，Java便已经支持NIO，我们完全可以采用JDK自带的NIO模块来开发网络组建，但是Java的NIO库有些问题，一是与OIO语法非常不同，如果你想从OIO迁移到NIO，那不好意思，恐怕要完完全全重新写一遍代码。二是使用复杂，业务逻辑和网络相关代码过度耦合，开发难度大，维护难度也很大。而netty，很好的解决了这些问题，使用简单，功能强大。 设计：为多种网络方式（NIO/OIO）提供统一的API接口，简单强大的线程模型，业务逻辑解耦，易于复用。 使用简单：提供详细的文档和丰富的案例，包教包会。 性能：和原生API有着更高的吞吐量和更低的延迟，可以通过线程池减少资源使用。 健壮性：不会因为过慢过快过量的连接造成OutOfMemoryError。消除NIO应用在高速网络下的读写不平衡。 安全：完全支持SSL/TLS和StartTLS 社区驱动：netty社区里个个都是人才。 netty核心组件netty核心组件由以下四个模块构成 Channels Callbacks Futures Events and handlers对于netty中的三个概念：resources, logic, 和 notifications netty-ChannelsChannels 是Java NIO中一个非常基本的概念 an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing. 可以简单理解为传输数据的通道，能被open/close,connect/disconnect netty-CallbakcsCallbakcs(回掉)，是异步编程中的常见概念，这个就不说了。 netty-FuturesFutures是一个较为抽象的概念，它作为placeholder，代表一个异步过程完成后的结果值。将来的某个时刻，在异步过程完结后，可以统统Futures访问这个结果。JDK中提供对Future接口的默认实现类非常一般，需要程序员手工检查状态，并会造成阻塞。因此Netty自己提供一个对Future接口的实现，称为ChannelFuture。通过向ChannelFuture注册Listener，待Future完成后会异步回掉Listener的方法。ChannelFuture使用示例123456789101112131415161718Channel channel = ...;// Does not blockChannelFuture future = channel.connect( new InetSocketAddress("192.168.0.1", 25));future.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) &#123; if (future.isSuccess())&#123; ByteBuf buffer = Unpooled.copiedBuffer( "Hello",Charset.defaultCharset()); ChannelFuture wf = future.channel().writeAndFlush(buffer); .... &#125; else &#123; Throwable cause = future.cause(); cause.printStackTrace(); &#125; &#125;&#125;); Callbakcs和Futures共同构成logic部分 netty- Events and handlersNetty采用了多种events，这些events用来表示网络连接中各类状态变化和操作的结果。当这些events被触发时，可以采取一系列操作来处理这些events。这些操作可以包括一下几类： 日志记录 数据转换 流控制 业务逻辑 Netty的events，可以根据inbound data和outbound data，分为以下几类。 Active or inactive connections Data Reads User event Error event inbound event 和 outbound event 数据流模型图对于每个event，都可以分配一个user-implement handler class来处理。当然Netty为Handler提供了一个基本抽象–ChannelHandler，并且提供一套预先处理好的Handler集合，可以支持HTTP 和 SSL/TLS协议。 年轻人的第一个Netty程序我们来实现一个具体的Netty Server/Client程序，这个程序非常简单，Server只需要简单将Client发送的数据原封不动的返回即可，这个简单的Server，我们称之为EchoServer。我们目的是为了了解Netty框架的使用，因此Server的业务逻辑越简单越好。 EchoServer代码EchoServer的业务逻辑通过EchoServerHandler来实现123456789101112131415161718192021@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf in = (ByteBuf) msg; System.out.println( "Server received: " + in.toString(CharsetUtil.UTF_8)); ctx.write(in); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; ChannelInboundHandlerAdapter默认实现了ChannelInboundHandler的接口，如果你只关心特定的event而不是所有event，可以通过继承ChannelInboundHandlerAdapter，其余的接口将会采用ChannelInboundHandlerAdapter的默认实现方法。这里我们主要处理以下三个event channelRead()当有数据写入时调用 channelReadComplete()当读入的数据是最后一个的时候调用 exceptionCaught()异常发生时调用 好了，接下来我们要启动这个服务器了。123456789101112131415161718192021222324252627282930313233343536public class EchoServer &#123; private final int port; public EchoServer(int port) &#123; this.port = port; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 1) &#123; System.err.println( "Usage: " + EchoServer.class.getSimpleName() + " &lt;port&gt;"); &#125; int port = Integer.parseInt(args[0]); new EchoServer(port).start(); &#125; public void start() throws Exceptio3n &#123; final EchoServerHandler serverHandler = new EchoServerHandler(); EventLoopGroup group = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(serverHandler); &#125; &#125;); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125;&#125; ChannelInitializer之前的都非常好理解，那么这个ChannelInitializer是起什么作用？当Server绑定到port后，会监听连接请求信息，当有连接建立的时候，还生成一个Channel，而ChannelInitializer则是负责对这个Channel初始化的，可见在initChannel中，initializer给Channel添加了一个EchoServerHandler实例。代码的最后，是同步绑定服务器。 EchoClient代码1234567891011121314151617181920212223@Sharablepublic class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; //建立连接是调用 @Override public void channelActive(ChannelHandlerContext ctx) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer("Netty rocks!", CharsetUtil.UTF_8); &#125; //从Server读到数据时调用 @Override public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) &#123; System.out.println( "Client received: " + in.toString(CharsetUtil.UTF_8)); &#125; //异常时调用 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStrackTrace(); ctx.close(); &#125;&#125; Client端的Handler和Server端很类似，不过这里是Inbound。注意， ChannelInboundHandlerAdapter也是存在的，不过这里并不采用，原因是SimpleChannelInboundHandler更简单了，它替我们处理一些内存释放等操作。 现在让我们启动client12345678910111213141516171819202122232425262728293031323334353637383940public class EchoClient &#123; private final String host; private final int port; public EchoClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public void start() throws Exception &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( new EchoClientHandler()); &#125; &#125;); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println( "Usage: " + EchoClient.class.getSimpleName() + " &lt;host&gt; &lt;port&gt;"); return; &#125; String host = args[0]; int port = Integer.parseInt(args[1]); new EchoClient(host, port).start(); &#125;&#125; client端的代码与server端非常相似，仅有几处细微差别。 Netty组件与设计在初步认识Netty之后，本章详细介绍下Netty的各个组件与设计。 Channel, EventLoop, and ChannelFutureChannel, EventLoop, 和 ChannelFuture这三个组件可以理解为对Netty的抽象。Channel是对Socket的抽象，EventLoop是对Control flow, multithreading, concurrency的抽象，ChannelFuture是对Asynchronous notification的抽象。 ChannelChannel定义了基础的IO操作，包括 bind(), connect(), read(), 和write()Netty预定义了一些Channel，用来简化应用开发。 EmbeddedChannel LocalServerChannel NioDatagramChannel NioSctpChannel NioSocketChannel使用这些Channel可以简化程序开发。 EventLoopEventLoop则是定义了connection的生命周期对事件处理的抽象。这里在一个高层次介绍Channels, EventLoops, Threads 以及EventLoopGroups之间的关系。 一个 EventLoopGroup 包含一个或多个 EventLoops. 一个 EventLoop 会绑定一个单独的线程. 所有的 I/O 事件都会被EventLoop的线程处理. 一个 Channel 会注册都一个EventLoop上. 一个 EventLoop 可能会拥有多个Channel. ChannelFutureChannelFuture负责在处理完成后的回掉工作。可以通过其addListener()注册一个ChannelFutureListener，用于在操作完成后进行回调（无论结果是否成功）。 ChannelHandler 和 ChannelPipelineChannelHandler 和 ChannelHandler 两个组件主要处理数据流和业务逻辑。 ChannelHandler从ChannelHandler的角度来看，这是最核心的类，因为其直接负责业务逻辑代码的处理。通过EventDriven机制，ChannelHandler处理各种类型的event，从而实现业务逻辑。从上面例子可以见，Netty一样实现多个默认类，来简化应用开发。 ChannelPipelineChannelPipeline可以理解为存放链式ChannelHandler的容器，我们将Socket视为外部，java application视作内部，ChannelHandler分为两类，ChannelInboundHandler表示数据从socket到java，ChannelOutBoundHandler则相反。handler在pipeline中按链式存储，数据或者事件从一个handler传递到下一个handler，虽然两类handler混在一个pipeline中，但是两者不会混淆，netty能分辩两者，流入数据只会被ChannelInboundHandler处理，流出数据只会被ChannelOutboundHandler处理。 当一个handler被添加到pipeline中，会被绑定一个ChannelHandlerContext，context代表handler和pipeline的一种绑定关系，你可以使用context获得底层Channel来进行操作，这种一般用来写输出数据，这会导致数据从pipeline tail开始。第二中则是将数据写入到context中，这将使下一个handler来处理数据。 netty为开发者提供了二者adapter类，方法均作了默认实现，不做任何处理传递到下一个handler，开发者只需覆盖自己感兴趣的方法，其他采用默认实现即可。 ChannelHandlerAdapter ChannelInboundHandlerAdapter ChannelOutboundHandlerAdapter ChannelDuplexHandlerAdapter 特殊handler：encoder和decoder。输出数据需要encode，从object转换成byte，输入数据需要decode，从byte转换成object。netty提供encoder/decoder不是ChannelInboundHandler就是ChannelOutboundHandler。 Bootstrappingnetty bootstrap类是提供应用网络层配置容器，可以绑定程序到给定端口或者连接到一个正在监听的主机端口上。前者一般称为server而后者一般称为client，netty也有两类bootstrap，bootstrapserver和bootstrap。两者差别除了上述行为外，还有一点很重要的，Bootstrap只有一个EventLoopGroup，而Bootstrap有两个EventLoopGroup。server需要两个不同EventLoopGroup，前者只有一个ServerChannel，用来创建对每一个连接创建Channel，并交由第二个EventLoopGroup中的EventLoop处理。应该就是运用到多路io复用技术。]]></content>
      <categories>
        <category>netty学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程学习笔记 后记]]></title>
    <url>%2F2018%2F11%2F03%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%90%8E%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这几篇学习笔记，基本是我这几个月阅读 JAVA高并发编程详解总结摘要与读后感。写下这几篇笔记，我复习了一遍其内容，并敲了敲代码，做了简单实现。将几百页内容压缩到几篇笔记中，实在是一件有趣的事情。前三篇内容，基本对应前三部分的内容，而第四篇，则是第四部分设计模式内容。这一部分，主要介绍和多线程相关的设计模式。数一数竟有15个，占了约有一半的内容，基本都是工作学习中见过的。]]></content>
      <categories>
        <category>java多线程学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程学习笔记（三）进阶]]></title>
    <url>%2F2018%2F11%2F03%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Java 多线程学习笔记（三）进阶自定义显示锁BooleanLocksynchronized虽然提供线程同步等功能，但他过于原始，有两个明显缺陷：第一，无法控制阻塞时长，第二，阻塞不可被中断。 定义锁接口123456public interface Lock &#123; void lock() throws InterruptedException; void lock(long mills) throws InterruptedException, TimeoutException; void unlock(); List&lt;Thread&gt; getBlockedThreads();&#125; 首先给BooleanLock定义如下成员变量，其中bollean变量记录锁状态，currentThread记录持锁线程，blockedList记录阻塞线程列表。 123456public static class BooleanLock implements Lock &#123; private Thread currentThread; private boolean locked = false; private final List&lt;Thread&gt; blockedList = new ArrayList&lt;&gt;(); ...&#125; 来具体看lock实现1234567891011121314151617181920@Overridepublic void lock() throws InterruptedException &#123; synchronized (this) &#123; while (locked) &#123; final Thread tempThread = currentThread(); try &#123; if (!blockedList.contains(tempThread)) &#123; blockedList.add(tempThread); this.wait(); &#125; &#125;catch (InterruptedException e) &#123; blockedList.remove(tempThread); throw e; &#125; &#125; blockedList.remove(currentThread()); this.locked = true; this.currentThread = currentThread(); &#125;&#125; lock是一个同步代码块，while循环当锁被其他线程锁定是会不停循环。实际上当blocked为true时，会添加该线程到阻塞队列里，随后将其进行wait。此时该线程放弃同步代码块的monitor锁，其他线程可以进入同步代码块，并且被唤醒后，需要重新获取锁，保证该操作肯定是互斥的,只有一个线程能拿到锁。 来看lock(long)实现123456789101112131415161718192021222324@Overridepublic void lock(long mills) throws InterruptedException, TimeoutException &#123; synchronized (this) &#123; if (mills &lt; 0) &#123; this.lock(); &#125; else &#123; long remainingMills = mills; long endMills = currentTimeMillis() + remainingMills; while (locked) &#123; if (remainingMills &lt;= 0) &#123; throw new TimeoutException("can not get the lock during" + mills); &#125; if (!blockedList.contains(currentThread())) &#123; blockedList.add(currentThread()); &#125; this.wait(remainingMills); remainingMills = endMills - currentTimeMillis(); &#125; blockedList.remove(currentThread()); this.locked = true; this.currentThread = currentThread(); &#125; &#125;&#125; 巧妙之处在于，调用wait(long)，当然，线程可能会被其他线程唤醒，所以当被唤醒后仍未获得锁，则继续进行循环，只是wait(long)时间缩短，当remainingMills &lt;= 0时，则判断为超时。 unlock代码12345678910@Overridepublic void unlock() &#123; synchronized (this) &#123; if (currentThread == currentThread()) &#123; this.locked = false; Optional.of(currentThread().getName() + " release the lock.").ifPresent(System.out::println); this.notifyAll(); &#125; &#125;&#125; 注意下，只有持有锁线程才能进行释放锁操作。重置locked，notifyAll() 自定义线程池从jdk1.5开始，utils包提供了ExecutorService线程池的实现。作为一个线程池，需要管理好线程资源，提高线程利用率和系统效率。 定义一个简单的线程池实现类图简单线程池类满足以下几点要求 任务队列：用于换成提交的任务 线程数量管理 任务拒绝策略 线程工厂 queueSize用于控制任务队列大小 Keepedalive时间：用了决定线程池自动维护时间 简单线程池采用如下规则管理线程。创建线程池时指定init大小作为初始大小，max大小作为线程自动扩充时最大线程数量，在线程池空闲时需要释放线程但也需要维护一定数量的活跃线程的core，这样线程能控制在一个合理的范围内，三者之间的关系是init&lt;=core&lt;=max ThreadPool接口定义如下。execute(Runnable)用来提交任务。12345678910public interface ThreadPool &#123; void execute(Runnable runnable); void shutdown(); int getInitSize(); int getMaxSize(); int getCoreSize(); int getQueueSize(); int getActiveCount(); boolean isShutdown();&#125; RunnableQueue接口定义如下。offer用于向队列提交任务，take用来获取任务。12345public interface RunnableQueue &#123; void offer(Runnable runnable); Runnable take() throws InterruptedException; int size();&#125; DenyPolicy接口定义如下。注意下RunnerDenyPolicy，直接在当前线程执行任务，这种设计在很多地方都有。12345678910111213141516171819202122232425262728public interface DenyPolicy &#123; void reject(Runnable runnable, ThreadPool threadPool); class DiscardDenyPolicy implements DenyPolicy &#123; @Override public void reject(Runnable runnable, ThreadPool threadPool) &#123; &#125; &#125; class AbortDenyPolicy implements DenyPolicy &#123; @Override public void reject(Runnable runnable, ThreadPool threadPool) &#123; throw new RunnableDenyException("The runnable " + runnable + " will be abort."); &#125; &#125; class RunnerDenyPolicy implements DenyPolicy &#123; public void reject(Runnable runnable, ThreadPool threadPool) &#123; if (!threadPool.isShutdown()) &#123; runnable.run(); &#125; &#125; &#125;&#125; RunnableDenyException定义如下。12345public class RunnableDenyException extends RuntimeException&#123; public RunnableDenyException(String message) &#123; super(message); &#125;&#125; InternalTask用来定义线程池内部线程逻辑，只要线程仍然处于running状态且不被打断，就会不停从RunnableQueue中获取task来执行。1234567891011121314151617181920212223242526public class InternalTask implements Runnable &#123; private final RunnableQueue runnableQueue; private volatile boolean running = true; public InternalTask(RunnableQueue runnableQueue) &#123; this.runnableQueue = runnableQueue; &#125; @Override public void run() &#123; while (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; try &#123; Runnable task = runnableQueue.take(); task.run(); &#125; catch (InterruptedException e) &#123; running = false; break; &#125; &#125; &#125; public void stop() &#123; this.running = false; &#125;&#125; LinkedRunnableQueue，用LinkedList实现的RunnableQueue，当线任务超过最大值，则reject，若是take不够，阻塞线程，当然是因为进行offer的是用户线程，而take的是线程池内部线程。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LinkedRunnableQueue implements RunnableQueue &#123; private final int limit; private final DenyPolicy denyPolicy; private final LinkedList&lt;Runnable&gt; runnableList = new LinkedList&lt;&gt;(); private final ThreadPool threadPool; public LinkedRunnableQueue(int limit, DenyPolicy denyPolicy, ThreadPool threadPool) &#123; this.limit = limit; this.denyPolicy = denyPolicy; this.threadPool = threadPool; &#125; @Override public void offer(Runnable runnable) &#123; synchronized (runnableList) &#123; if (runnableList.size() &gt;= limit) &#123; denyPolicy.reject(runnable,threadPool); &#125; else &#123; runnableList.addLast(runnable); runnableList.notifyAll(); &#125; &#125; &#125; @Override public Runnable take() throws InterruptedException &#123; synchronized (runnableList) &#123; while (runnableList.isEmpty()) &#123; try &#123; runnableList.wait(); &#125; catch (InterruptedException e) &#123; throw e; &#125; &#125; return runnableList.removeFirst(); &#125; &#125; @Override public int size() &#123; synchronized (runnableList) &#123; return runnableList.size(); &#125; &#125;&#125; 最后也是最关键的是BasicThreadPool，作为ThreadPool实现类。BasicThreadPool继承Thread并实现了ThreadPool接口。在init方法内部默认启动自身线程。BasicThreadPool默认创建initSize大小的线程，并通过keepAliveTime参数控制线程执行周期，用来增加或者减少线程池线程数量。其内部使用threadQueue成员，来管理线程池线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186public class BasicThreadPool extends Thread implements ThreadPool &#123; private final int initSize; private final int maxSize; private final int coreSize; private int activeCount; private final ThreadFactory threadFactory; private final RunnableQueue runnableQueue; private volatile boolean isShutdown = false; private final Queue&lt;ThreadTask&gt; threadQueue = new ArrayDeque&lt;&gt;(); private final static DenyPolicy DEFAULT_DENY_POLICY = new DenyPolicy.DiscardDenyPolicy(); private final static ThreadFactory DEFAULT_THREAD_FACTORY = new DefaultThreadFactory(); private final long keepAliveTime; private final TimeUnit timeUnit; public BasicThreadPool(int initSize, int maxSize, int coreSize, int queueSize) &#123; this(initSize,maxSize,coreSize,DEFAULT_THREAD_FACTORY, queueSize,DEFAULT_DENY_POLICY,10,TimeUnit.SECONDS); &#125; public BasicThreadPool(int initSize,int maxSize,int coreSize, ThreadFactory threadFactory, int queueSize, DenyPolicy denyPolicy, long keepAliveTime, TimeUnit timeUnit) &#123; this.initSize = initSize; this.maxSize = maxSize; this.coreSize = coreSize; this.threadFactory = threadFactory; this.runnableQueue = new LinkedRunnableQueue(queueSize,denyPolicy,this); this.keepAliveTime = keepAliveTime; this.timeUnit = timeUnit; this.init(); &#125; private void init() &#123; start(); for (int i = 0; i &lt; initSize; i++) &#123; newThread(); &#125; &#125; @Override public void execute(Runnable runnable) &#123; if (this.isShutdown) &#123; throw new IllegalArgumentException("The thread pool is destroy"); &#125; this.runnableQueue.offer(runnable); &#125; private void newThread() &#123; InternalTask internalTask = new InternalTask(runnableQueue); Thread thread = this.threadFactory.createThread(internalTask); ThreadTask threadTask = new ThreadTask(thread,internalTask); threadQueue.offer(threadTask); this.activeCount++; thread.start(); &#125; private void removeThread() &#123; ThreadTask threadTask = threadQueue.remove(); threadTask.internalTask.stop(); this.activeCount--; &#125; @Override public void run() &#123; while (!isShutdown &amp;&amp; !isInterrupted()) &#123; try &#123; timeUnit.sleep(keepAliveTime); &#125; catch (InterruptedException e) &#123; isShutdown = true; break; &#125; synchronized (this) &#123; if (isShutdown) &#123; break; &#125; if (runnableQueue.size() &gt; 0 &amp;&amp; activeCount &lt; coreSize) &#123; for (int i = initSize; i &lt; coreSize; i++) &#123; newThread(); &#125; continue; &#125; if (runnableQueue.size() &gt; 0 &amp;&amp; activeCount &lt; maxSize) &#123; for (int i = coreSize; i &lt; maxSize; i++) &#123; newThread(); &#125; &#125; if (runnableQueue.size() == 0 &amp;&amp; activeCount &gt; coreSize) &#123; for (int i = coreSize; i &lt; activeCount; i++) &#123; removeThread(); &#125; &#125; &#125; &#125; &#125; @Override public void shutdown() &#123; synchronized (this) &#123; if (isShutdown) &#123; return; &#125; isShutdown = true; threadQueue.forEach(threadTask -&gt; &#123; threadTask.internalTask.stop(); threadTask.thread.interrupt(); &#125;); this.interrupt(); &#125; &#125; @Override public int getInitSize() &#123; if (isShutdown) &#123; throw new IllegalStateException("The thread pool is destory"); &#125; return this.initSize; &#125; @Override public int getMaxSize() &#123; if (isShutdown) &#123; throw new IllegalStateException("The thread pool is destory"); &#125; return this.maxSize; &#125; @Override public int getCoreSize() &#123; if (isShutdown) &#123; throw new IllegalStateException("The thread pool is destory"); &#125; return this.coreSize; &#125; @Override public int getQueueSize() &#123; if (isShutdown) &#123; throw new IllegalStateException("The thread pool is destory"); &#125; return runnableQueue.size(); &#125; @Override public int getActiveCount() &#123; synchronized (this) &#123; return this.activeCount; &#125; &#125; @Override public boolean isShutdown() &#123; return this.isShutdown; &#125; private static class ThreadTask &#123; Thread thread; InternalTask internalTask; public ThreadTask(Thread thread, InternalTask internalTask )&#123; this.thread = thread; this.internalTask = internalTask; &#125; &#125; private static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger GROUP_COUNTER = new AtomicInteger(1); private static final ThreadGroup group = new ThreadGroup("MyThreadPool-" + GROUP_COUNTER.getAndDecrement()); private static final AtomicInteger COUNTER = new AtomicInteger(0); @Override public Thread createThread(Runnable runnable) &#123; return new Thread(group,runnable,"thread-pool-" + COUNTER.getAndDecrement()); &#125; &#125;&#125; 单例模式单例模式是最常见的设计模式之一，在多线程情况下，我们需要保证单例模式满足这样的要求：线程安全、高性能、懒加载。 饿汉式实现简单，实例对象在使用Singleton1类时，便会进行加载创建。线程安全，但是不满足懒加载特性。 12345678910public static class Singleton1 &#123; private byte[] data = new byte[1024]; private static Singleton1 instance = new Singleton1(); private Singleton1() &#123; &#125; public static Singleton1 getInstance() &#123; return instance; &#125;&#125; 懒汉式实现简单，instance实例化是在实际调用到getInstance之后才触发的，符合懒加载的特点，但显然，不能保证线程安全。 12345678910111213public static class Singleton2 &#123; private byte[] data = new byte[1024]; private static Singleton2 instance = null; private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; if (instance == null) &#123; instance = new Singleton2(); &#125; return instance; &#125;&#125; 同步懒汉式给getInstance方法加上同步约束，可以保证懒加载和线程安全，但是每次getInstance均会进行同步，影响性能。 12345678910111213public static class Singleton3 &#123; private byte[] data = new byte[1024]; private static Singleton3 instance = null; private Singleton3() &#123; &#125; public static synchronized Singleton3 getInstance() &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; return instance; &#125;&#125; 两次验证懒汉式这种写法，基本能回避前面三种遇到的问题，事实上，大学期间大作业，也是多用这种方式实现单例模式。但仔细思考，这种方式仍存在问题，比如，当实例化需要较长的时间，比如内部需要操作socket或者connect等耗时操作，instance!=null虽然满足，但是内部操作未完成，其他线程使用instance实例，仍然会出错。（这是JAVA高并发编程详解给出不好理由，并未实际进行验证） 1234567891011121314151617public static class Singleton4 &#123; private byte[] data = new byte[1024]; private static Singleton4 instance = null; private Singleton4() &#123; &#125; public static Singleton4 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton4.class) &#123; if (instance == null) &#123; instance = new Singleton4(); &#125; &#125; &#125; return instance; &#125;&#125; volatile两次验证懒汉式volatile可以防止指令重排。这种模式符合三大特性。 1private volatile static Singleton5 instance = null; 内部类这种设计较为巧妙，利用java类加载机制，直到调用 getInstance后才会对内部类Holder进行加载，并对instance实例化，而java类加载机制，能保证只被加载一次。符合三大特性。这种方式是较为常见单例模式设计之一。 123456789101112public static class Singleton6 &#123; private byte[] data = new byte[1024]; private Singleton6() &#123; &#125; private static class Holder &#123; private static Singleton6 instance = new Singleton6(); &#125; public static Singleton6 getInstance() &#123; return Holder.instance; &#125;&#125; 枚举方式这是一种更巧妙的方法，用java枚举类特性保证单例化与线程安全，但是并不能完全保证懒加载，当访问到静态方法时，也可能会实例化。12345678910public static enum Singleton7 &#123; INSTANCE; private byte[] data = new byte[1024]; private static void method() &#123; //... &#125; public static Singleton7 getInstance() &#123; return INSTANCE; &#125;&#125; 对其使用内部类修缮1234567891011121314151617181920public static class Singleton8 &#123; private byte[] data = new byte[1024]; private Singleton8() &#123; &#125; private enum Holder &#123; INSTANCE; private Singleton8 instance; Holder() &#123; this.instance = new Singleton8(); &#125; private Singleton8 getSingleton() &#123; return instance; &#125; &#125; public static Singleton8 getInstance() &#123; return Holder.INSTANCE.getSingleton(); &#125;&#125;]]></content>
      <categories>
        <category>java多线程学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[双十一购书清单]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%8F%8C%E5%8D%81%E4%B8%80%E8%B4%AD%E4%B9%A6%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[又到一年一度的双十一了，趁着京东书籍促销，剁了一手。这次购买的书籍如下： Java高并发编程详解：多线程与架构设计 Netty权威指南 Effective java go程序设计语言 Spring实战 go语言学习笔记 GO Web编程 架构整洁之道 其中Java高并发编程这本，之前已经基本阅读过一遍电子版，此次算是支持作者，购买一本。读后感觉非常棒，作者并未介绍过多实战方面的知识，而是以背后原理为主，深入浅出介绍多线程相关技术，解答了之前不少感到疑惑的知识点。 Netty权威指南则是我下一阶段打算认真研读的。作为java最出名的第三方io库，早已久闻netty大名，工作中也会遇到netty相关的事情。此前读过netty in action，现在想继续深入学习下java网络多线程相关知识，故而买了一本。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程学习笔记（二）基础]]></title>
    <url>%2F2018%2F11%2F01%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java 多线程学习笔记（二）基础synchronized 关键字synchronized关键字可修饰方法或代码块，被修饰的部分，对于多线程来说将按照同步方式来执行。 synchronized 提供一种锁机制，能确保共享变量互斥访问，从而防止数据不一致问题。 synchronized 关键字包括monitor enter 和 monitor exit 两个jvm指令，保证任何线程执行到monitor enter之前都必须从主存中获取数据，而不是从缓存中，monitor exit之后，共享变量被更新后的值必须刷入到主内存中。 synchronized 严格遵守java happen-before 原则，一个monitor exit之前必须要有一个monitor exit synchronized 修饰同步方法1234567public synchronized void sync() &#123;// code &#125;public synchronized static void sync() &#123;// code&#125; synchronized 修饰同步代码块123456private final Object MUTEX = new Object();public void sync() &#123; synchronized (MUTEX) &#123; // code &#125;&#125; 线程需要获得MUTEX对象相关联的monitor锁，才能执行同步代码块。未获得monitor锁的线程，将会处于blocked状态。 synchronized注意点 与monitor关联对象不能为空 synchronized作用域不应太大 各个线程争取的monitor关联对象应该是同一个 小心死锁 This Monitor 和 Class Monitor同步代码块可以手动设定需要关联锁的MUTEX对象。那么，同步方法呢？ 同步方法争抢的是This Monitor的关联锁，this是指的该类实例对象。故，同一对象的不同同步实例方法，以及synchronized(this)都是互斥的。 同步静态方法，争抢的是该类的class实例对象所关联的锁。因而不同同步静态代码也是互斥的。 wait 和 notifywait和notify方法，是Object中的方法，意味着所有java对象都有着两个方法。调用某个对象的wait方法，可使执行线程进入等待。而调用某个对象的notify方法，可使因为调用该对象的wait方法进入等待的线程唤醒。 wait方法有三个重载方法。123public final void wait() throws InterruptedExceptionpublic final void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout,int nanos) throws InterruptedException wait这三个方法最终都调用到wait(long)，wait()等价于wait(0)意味着用不超时，后两个会设置超时时间。超时时间指在该时间内未被唤醒，将会触发超时。 调用wait方法，必须先拥有该对象的关联锁，也就是说在该对象非同步代码块中调用wait方法会抛出异常。 当前线程执行了该对象的wait方法后，会放弃该对象的monitor锁并进入与该对象相关的wait set中，意味着其他线程有机会继续争抢该monitor的所有权。 notify方法1public final native void notify() 唤醒单个正在执行该对象wait方法的线程。 如果没有这样的线程，忽略该操作。 被唤醒的线程需要重新获取该对象所关联的monitor锁才能继续执行。 关于wait和notify的注意事项 wait方法是可中断方法，其他线程interrupt是可以将其打断的。 线程执行某个对象的wait方法会进入与之对应的wait set中。每个对象的monitor都有一个与之对应的wait set wait和notify都必须在该对象的同步代码中使用，否则会报IllegalMonitorStateException，同步代码的monitor和与执行wait notify方法的对象一致，简单地说用哪个对象的monitor进行同步，就只能用哪个对象进行wait和notify操作。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class EventQueue &#123; private final int max; static class Event &#123; &#125; private final LinkedList&lt;Event&gt; eventQueue = new LinkedList&lt;&gt;(); private final static int DEFAULT_MAX_EVENT = 10; public EventQueue(int max) &#123; this.max = max; &#125; public EventQueue() &#123; this(DEFAULT_MAX_EVENT); &#125; public void offer(Event event) &#123; synchronized (eventQueue) &#123; if (eventQueue.size() &gt;= max) &#123; try &#123; console("this queue is full"); eventQueue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; console(" the new event is submitted"); eventQueue.addLast(event); eventQueue.notify(); &#125; &#125; public Event take() &#123; synchronized (eventQueue) &#123; if (eventQueue.isEmpty()) &#123; try &#123; console(" the queue is empty"); eventQueue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Event event = eventQueue.removeFirst(); this.eventQueue.notify(); console(" the event " + event + " is handled"); return event; &#125; &#125; private void console(String message) &#123; System.out.printf("%s:%s\n",Thread.currentThread().getName(),message); &#125; &#125; 1234567891011121314151617181920212223242526272829package org.chenghao.concurrent;import java.util.concurrent.TimeUnit;public class EventClient &#123; public static void main(String[] args) &#123; final EventQueue eventQueue = new EventQueue(); new Thread( () -&gt; &#123; while (true) &#123; eventQueue.offer(new EventQueue.Event()); &#125; &#125;, "Producer" ).start(); new Thread( () -&gt; &#123; while (true) &#123; eventQueue.take(); try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "Consumer" ).start(); &#125;&#125; 多线程通信上述示例代码，在多线程会出现问题。原因在于consumer和producer都是由同一个对象阻塞，producer并不能指定唤醒consumer，相反很可能唤醒一个producer。同样的情况对consumer也是存在的。 修改方法,将if-&gt;while,notify-&gt;notifyAll 12345678910111213141516171819202122232425262728293031323334public void offer(Event event) &#123; synchronized (eventQueue) &#123; while (eventQueue.size() &gt;= max) &#123; try &#123; console("this queue is full"); eventQueue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; console(" the new event is submitted"); eventQueue.addLast(event); eventQueue.notifyAll(); &#125; &#125; public Event take() &#123; synchronized (eventQueue) &#123; while (eventQueue.isEmpty()) &#123; try &#123; console(" the queue is empty"); eventQueue.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Event event = eventQueue.removeFirst(); this.eventQueue.notifyAll(); console(" the event " + event + " is handled"); return event; &#125; &#125; ThreadGroupjava程序中，任何一个线程，都会属于一个ThreadGroup中，默认情况下，新创建的线程会被加入到main线程所在的ThreadGroup中。创建ThreadsGroup语法如下：12public ThreadGroup(String name)public ThreadGroup(ThreadGroup parent, String name) 若是不指定其父group，则默认是创建线程所在的ThreadGroup。ThreadGroup提供复制Threads功能12public int enumerate(Thread[] list)public int enumerate(Thread[] list, boolean recurse) enumerate(list)默认调用enumerate(list,true),会迭代复制。类似的也有复制整个ThreadGroup数组12public int enumerate(ThreadGroup[] list)public int enumerate(Thread[] list, boolean recurse) 效果类似。守护ThreadGroup，将ThreadGroup设置为daemon，并不会影响其内部的线程daemon属性。当ThreadGroup的daemon设置为true后，那么当该group中没有任何active线程的时候，group将自动destroy。 线程运行时异常UncaughtExceptionHandler线程的执行单元是不能抛出checked异常的，可以使用UncaughtExceptionHandler接口来获取线程运行时异常信息，当线程运行出现异常是，将会回调该方法。1234@FunctionInterfacepublic interface UncaughtExceptionHandler &#123; void uncaughtException(Thread t, Throwable e);&#125; 该方法会被Thread中的dispatchUncaughtException方法调用。12345678910111213141516171819202122public class CaptureThreadException &#123; public static void main(String[] args) &#123; Thread.setDefaultUncaughtExceptionHandler( (t, e) -&gt; &#123; System.out.println(t.getName() + " occur exception"); e.printStackTrace(); &#125; ); final Thread thread = new Thread( () -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(1/0); &#125;, "Test-Thread" ); thread.start(); &#125;&#125; 如果Thread未注入UncaughtExceptionHandler，将会返回group。group也是一个该接口的实现类，默认情况下，会寻找父group的Handler，如果没有父group，则寻找全局默认Handler，都没有，则输出到err中。 钩子线程可通过Runtime.getRuntime().addShutdownHook(Thread t)来注入钩子线程，当jvm退出时，线程被执行。可以注入多个线程，均会被启动。钩子线程可以用来在jvm退出时，清除锁等操作。 注意钩子线程只有在收到退出信号时才会执行，比如ctrl+c或者kill。但是kill -9不行。]]></content>
      <categories>
        <category>java多线程学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 多线程学习笔记（一）入门]]></title>
    <url>%2F2018%2F11%2F01%2Fjava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java 多线程学习笔记（一）入门Tread 与 Runnable 的区别众所周知，实现线程有两种模式，其一继承Thread类，覆盖run方法，其二，实现Runnable接口。前一种体现的模板类设计模式，后者体现的是策略模式，二者并无优劣高低之分，各有各的区别， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// SimpleThread的num是各个线程的私有成员，线程对自己num递增不会影响其他线程，若想改成线程相互影响，则需要加入staticclass SimpleThread extends Thread &#123; private int num = 0; public SimpleThread(String name) &#123; super(name); &#125; @Override public void run()&#123; while (true) &#123; System.out.println( this.getName() + "=" + ++num); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public void threadShow() &#123; IntStream.range(0,5).mapToObj( (num) -&gt; new SimpleThread("SimpleThread-" + num) ).forEach(Thread::start); &#125;// 传入Runnabel接口，几个线程均执行的是该对象的run方法，因此无需要static修饰num，几个线程对num操作会相互影响。 class SimpleRunnable implements Runnable&#123; private int num = 0; @Override public void run() &#123; while (true) &#123; System.out.println( Thread.currentThread().getName() + "=" + ++num); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public void runnableShow() &#123; SimpleRunnable simpleRunnable = new SimpleRunnable(); IntStream.range(0,5).mapToObj( (num) -&gt; new Thread(simpleRunnable,"SimpleRunnable-" + num) ).forEach(Thread::start); &#125; Java 内存结构，Thread与虚拟机栈 程序计数器 线程私有 java虚拟机栈 线程私有 通过-xss配置 本地方法栈 jni调用使用 线程私有 堆内存，线程共享，几乎存放java运行期间创建的所有对象，是GC重点关注区域，又称“GC堆” 方法区 线程共享 java 8 元空间 粗略认为Java进程内存大小为 堆内存 + 线程数量*栈内存 守护线程又称后台线程，随jvm退出而退出，当jvm存在一个非守护线程时，jvm不会自动退出。 Thread sleep 与 yieldsleep使当前线程进入睡眠状态。可以使用TimeUnit来代替sleep方法。yield是启发式方法，提醒调度器自愿放弃当前CPU资源，当CPU资源不紧张时，可能会忽略。 item sleep yield 一定执行 是 否 捕获中断 是 否 Thread 优先级Thread 优先级也是个hint操作，你不能严重依赖优先级来实现业务逻辑。线程优先级在1-10之间，且不能超过group的优先级。默认情况下，优先级和父线程优先级一致，通常是5，因为main优先级默认是5。 Thread interrupt线程 interrupt 与 可中断方法以下方法会使线程进入阻塞状态，调用该线程的interrupt方法，可以打断阻塞。 Object wait 及其重载方法 Thread sleep 及其重载方法 Thread join 及其重载方法 InterruptibleChannel 的 io 操作 Selector 的 wakeup 方法 其他方法 以上方法又称可中断方法。记住打断一个线程并不等于该线程生命周期结束，仅仅是打断了当前线程的阻塞状态。一旦线程在阻塞情况下被打断，会抛出InterruptException的异常，该异常就像一个signal信号一样，通知当前线程被打断了。 isInterrupted 和 InterruptedisInterrupted。该方法是线程成员方法，对线程Interrupt标识的一个判断，并不会影响该标识发生任何改变。interrupted。是一个静态方法，调用该方法会擦除线程的interrupt标识。如果线程被打断，那么调用该方法，第一次返回true，随后调用只会返回false，除非线程再次被打断。 可中断方法（如sleep）在捕获到中断信号，会重置interrupt标识。 12345678910111213141516public static void noSleep() throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); TimeUnit.MILLISECONDS.sleep(2); System.out.printf("Thread is interrupted ? %s\n",thread.isInterrupted()); thread.interrupt(); System.out.printf("Thread is interrupted ? %s\n",thread.isInterrupted());&#125; 123456789101112131415161718192021public static void withSleep() throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; try &#123; TimeUnit.MINUTES.sleep(1); &#125; catch (InterruptedException e) &#123; System.out.printf("I am be interrupted ? %s\n", isInterrupted()); &#125; &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); TimeUnit.MILLISECONDS.sleep(2); System.out.printf("Thread is interrupted ? %s\n",thread.isInterrupted()); thread.interrupt(); TimeUnit.MILLISECONDS.sleep(2); System.out.printf("Thread is interrupted ? %s\n",thread.isInterrupted());&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread()&#123; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.interrupted()); &#125; &#125; &#125;; thread.setDaemon(true); thread.start(); TimeUnit.MILLISECONDS.sleep(2); thread.interrupt();&#125; isInterrupted 和 interrupted均调用同一个本地方法：1private native boolean isInterrupted(boolean clearInterrupted); 当线程在可中断方法前被中断，则后续的可中断方法将立即中断。 Thread join当前线程A join 某个线程B，会使当前线程A处于blocked状态进入等待，直到B线程结束或者达到给定的时间。 Thread退出线程完成后正常结束手动控制线程退出线程创建与销毁，具有较高的成本。因此一个线程往往循环执行某些工作，比如心跳检查或是其他工作。当决定退出的时候可以使用线程中断等方式使其退出。12345public void run() &#123; while (!isInterrupted()) &#123; // working &#125;&#125; 当其他线程调用interrupt后，可使线程退出。当然，由于interrupt受中断方法影响，故可以采用volatile修饰的开关flag来控制，volatile关键字是使对象修改后强制在各个线程内进行同步。 1234567private volatile boolean closed = false;@Overridepublic void run() &#123; while (!closed &amp;&amp; !isInterrupt()) &#123; // working &#125;&#125; 通过unchecked exception使线程异常退出可以手动checked异常封装程unchecked exception（Runtime Exception）抛出来结束线程。 线程假死需通过其他工具如jconsole，jstack来分析线程假死原因。]]></content>
      <categories>
        <category>java多线程学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First look on protobuf with java]]></title>
    <url>%2F2018%2F10%2F31%2FFirst-look-on-protobuf-with-java%2F</url>
    <content type="text"><![CDATA[protobuf 性质速览proto2protobuf语法分为proto2和proto3，此处只介绍proto2的语法。 Messageprotobuf数据以message为单元12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125; message每条filed由以下构成rules type name = number;[option]rules 用来限定该filed属性 required optional repeated required表示一定需要该filed。optional表示可选filed。可以设置optional的默认值，如果未设置，protobuf会依据filed的type设置默认的默认值。（实际上在parse过程中，protobuf会为optional filed设置一个默认值）1optional int32 result_per_page = 3 [default = 10]; repeated表示可重复filed。 type 描述该filed类型 scalar type message enumeration name表示该filed名字number用来在message binary format中标识该filed reversed filed当你将旧有的filed删除或注释掉的之后，添加新的filed使用旧有number，这看起来似乎没有什么问题，但当你的程序读取旧数据则会产生data corruption等问题。为了避免这种情况，推荐将不再使用的filed设置成为reversed。1234message Foo &#123; reserved 2, 15, 9 to 11; reserved &quot;foo&quot;, &quot;bar&quot;;&#125; import当你需要使用其他文件定义的message，先import该message所在的文件。1import &quot;myproject/other_protos.proto&quot;; 默认情况下，你只能引用在该文件中定义的类型。如果你想使用，引用文件中引用的类型，请在引用文件中使用import public。这么说可能过于复杂，设想以下情景。当你决定移动某个proto文件，而不想逐一修改引用该proto文件的引用语句，可以这样操作。将proto文件移动到new_proto文件，在old_proto文件中使用import pulic来引用new_proto。你需要给protocol compiler添加-I/–proto_path参数来表示proto文件所在路径，默认情况下会是compiler被调用的路径。 scalar value typesprotobuf支持的原生type。scalar types Enumerations类似于java中的enumeration，你可以将其定义在message中也可以定义在message外，如果你想使用其他message中的enum，使用这种写法MessageType.EnumType。注意：enum的数值常量应在32bit以内。由于enum使用变长编码，负数值会造成低效率故不推荐。123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 同样你也可以将enum的value设为保留值，以避免读取旧数据时产生问题。1234enum Foo &#123; reserved 2, 15, 9 to 11, 40 to max; reserved &quot;FOO&quot;, &quot;BAR&quot;;&#125; nested types除了在message内部定义enum，你也可以在message内部定义message。如果你想在外部使用该message，使用这种语法Parent.Type。1234567891011message SearchResponse &#123; message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3; &#125; repeated Result result = 1;&#125;message SomeOtherMessage &#123; optional SearchResponse.Result result = 1;&#125; Extensions你可以在message内部声明一个一段数字作为extension保留。允许其他proto给该message添加新filed。1234567message Foo &#123; // ... extensions 100 to 199;&#125;extend Foo &#123; optional int32 bar = 126;&#125; 虽然Foo编码后，其wire format同定义了一个新的filed的Foo相同，但是代码内访问该filed和访问普通filed有些不同。12Foo foo;foo.SetExtension(bar, 15); 可以在message内部定义一个extension123456message Baz &#123; extend Foo &#123; optional int32 bar = 126; &#125; ...&#125; 它需要这样访问（c++code）12Foo foo;foo.SetExtension(Baz::bar, 15); 当然有个有趣的操作就是，你可以在定义一个extension在其本身中。123456message Baz &#123; extend Foo &#123; optional Baz foo_ext = 127; &#125; ...&#125; 这或许有些难以理解，其实这和以下等效。12345678message Baz &#123; ...&#125;// This can even be in a different file.extend Foo &#123; optional Baz foo_baz_ext = 127;&#125; Oneof如果你有一些optional filed，同时很明确这些filed同时最多只有一个能被设置。你可以使用oneof123456message SampleMessage &#123; oneof test_oneof &#123; string name = 4; SubMessage sub_message = 9; &#125;&#125; 注意，oneof不能使用rules词（optional、required和repeated）修饰。如果我想repeated怎么办？把oneof的某个filed设为包含repeated filed的message type。当你尝试给oneof设置值时，会清除其前一个值。在c++中请小心使用，因为你很可能持有旧有引用而引起问题。1234SampleMessage message;SubMessage* sub_message = message.mutable_sub_message();message.set_name(&quot;name&quot;); // Will delete sub_messagesub_message-&gt;set_... // Crashes here Mapsmap类型定义如下1map&lt;key_type, value_type&gt; map_field = N; key_type可以是任意integer或者string类型，所以除float point类型和bytes类型外的其他任何scalar类型均可以做为key_type.注意 不支持extension 不支持repeated，optional和required wire format 顺序和map迭代顺序并未定义，因此你不能依赖map item顺序 生成的text format中，maps会按key排序。 当解析wire format时，如果出现重复key，则会以最后一个为准，但是解析text format，重复key会出错。 兼容性，对于不支持map的protobuf实现，会议以下方式处理map。123456message MapFieldEntry &#123; optional key_type key = 1; optional value_type value = 2;&#125;repeated MapFieldEntry map_field = N; Packages使用package来避免.proto的命名冲突。12package foo.bar;message Open &#123; ... &#125; 可以这样使用Open12345message Foo &#123; ... required foo.bar.Open open = 1; ...&#125; Services如果你想在RPC中使用你的message类型，你可以在.proto文件中定义RPC service interface接口。随后protobuf compiler会自动根据你的语言生产服务接口代码和桩代码。比如你想创建一个使用SearchRequest和SearchResponse的RPC服务，你可以做出如下定义。123service SearchService &#123; rpc Search (SearchRequest) returns (SearchResponse);&#125; Optionsjava常用option java_package (file option) 定义生产代码所在包 java_outer_classname (file option) 定义生成代码类名 optimize_for (file option)： 优化方式 proto3tbd Encoding涉及底层编码方式tbd protobuf for JAVA简单定义一个person.proto1234567891011121314151617181920212223242526272829syntax = &quot;proto2&quot;;package tutorial;option java_package = &quot;com.example.tutorial&quot;;option java_outer_classname = &quot;AddressBookProtos&quot;;message Person &#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 生成java code，可以使用command-line1protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto 如果使用maven,maven可以自动帮你生成相应代码。12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt;...&lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;configuration&gt; &lt;protocExecutable&gt;protoc&lt;/protocExecutable&gt; &lt;protoSourceRoot&gt;$&#123;basedir&#125;/protobuf&lt;/protoSourceRoot&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Serializer codePerson john = Person.newBuilder() .setId(1234) .setName("John Doe") .setEmail("jdoe@example.com") .addPhones(Person.PhoneNumber.newBuilder() .setNumber("555-4321") .setType(Person.PhoneType.HOME)) .build();Person kulisu = Person.newBuilder() .setId(1000) .setName("kulisu") .setEmail("Kulisu@outlook.com") .addPhones(Person.PhoneNumber.newBuilder() .setNumber("173xxxx8086") .setType(Person.PhoneType.MOBILE)) .build();AddressBook addressBook = AddressBook.newBuilder() .addPeople(john) .addPeople(kulisu) .build();File file = new File("person.data");try (FileOutputStream fileOutputStream = new FileOutputStream(file)) &#123; addressBook.writeTo(fileOutputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;// parser codeFile file = new File("person.data");try (FileInputStream fileInputStream = new FileInputStream(file)) &#123; AddressBook addressBook = AddressBook.parseFrom(fileInputStream); for (Person person: addressBook.getPeopleList()) &#123; System.out.println("Person ID: " + person.getId()); System.out.println(" Name: " + person.getName()); if (person.hasEmail()) &#123; System.out.println(" E-mail address: " + person.getEmail()); &#125; for (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123; switch (phoneNumber.getType()) &#123; case MOBILE: System.out.print(" Mobile phone #: "); break; case HOME: System.out.print(" Home phone #: "); break; case WORK: System.out.print(" Work phone #: "); break; &#125; System.out.println(phoneNumber.getNumber()); &#125; &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 执行结果如下12345678Person ID: 1234 Name: John Doe E-mail address: jdoe@example.com Home phone #: 555-4321Person ID: 1000 Name: Kulisu E-mail address: Kulisu@outlook.com Mobile phone #: 173xxxx8086]]></content>
      <tags>
        <tag>java</tag>
        <tag>protobuf</tag>
        <tag>code</tag>
      </tags>
  </entry>
</search>
